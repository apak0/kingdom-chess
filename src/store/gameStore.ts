import { create } from "zustand";
import { Chess, Square as ChessSquare } from "chess.js";
import { io } from "socket.io-client";
import { Piece as PieceType, PieceColor, Position } from "../types";

// Yardƒ±mcƒ± fonksiyonlar
const convertToChessNotation = (pos: Position): string => {
  const files = ["a", "b", "c", "d", "e", "f", "g", "h"];
  const ranks = ["8", "7", "6", "5", "4", "3", "2", "1"];
  return files[pos.x] + ranks[pos.y];
};

const pieceTypeMap: Record<string, PieceType["type"]> = {
  p: "pawn",
  n: "knight",
  b: "bishop",
  r: "rook",
  q: "queen",
  k: "king",
};

const convertPieceFromChess = (piece: any): PieceType | null => {
  if (!piece) return null;

  const type = pieceTypeMap[piece.type];
  if (!type) return null;

  const color: PieceColor = piece.color === "w" ? "white" : "black";
  return {
    type,
    color,
    hasMoved: true,
  };
};

const convertBoardFromChess = (chess: Chess): (PieceType | null)[][] => {
  const board: (PieceType | null)[][] = Array(8)
    .fill(null)
    .map(() => Array(8).fill(null));

  for (let y = 0; y < 8; y++) {
    for (let x = 0; x < 8; x++) {
      const square = convertToChessNotation({ x, y }) as ChessSquare;
      const piece = chess.get(square);
      board[y][x] = piece ? convertPieceFromChess(piece) : null;
    }
  }

  return board;
};

const findBestMove = (chess: Chess): string => {
  const moves = chess.moves({ verbose: true });
  if (moves.length === 0) return "";

  // Basit bir deƒüerlendirme
  return moves[Math.floor(Math.random() * moves.length)].san;
};

// Socket.IO baƒülantƒ±sƒ±
const SERVER_URL = import.meta.env.VITE_SERVER_URL || "http://localhost:3001";
console.log("Connecting to server:", SERVER_URL);

const socket = io(SERVER_URL, {
  transports: ["polling", "websocket"],
  reconnection: true,
  reconnectionAttempts: Infinity,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  timeout: 20000,
  autoConnect: true,
  forceNew: true,
});

socket.on("connect", () => {
  console.log("Socket baƒülantƒ±sƒ± kuruldu:", socket.id);
});

socket.on("connect_error", (error) => {
  console.error("Socket baƒülantƒ± hatasƒ±:", error);
});

socket.on("disconnect", (reason) => {
  console.log("Socket baƒülantƒ±sƒ± kesildi:", reason);
});

interface GameState {
  chess: Chess;
  board: (PieceType | null)[][];
  selectedPiece: { position: Position; piece: PieceType } | null;
  currentPlayer: PieceColor;
  moves: { from: Position; to: Position }[];
  capturedPieces: {
    white: PieceType[];
    black: PieceType[];
  };
  isCheckmate: boolean;
  isStalemate: boolean;
  modalState: {
    isOpen: boolean;
    title: string;
    message: string;
    type: "check" | "checkmate" | "stalemate";
  };
  roomId: string | null;
  isMultiplayer: boolean;
  playerColor: PieceColor | null;
  selectPiece: (position: Position) => void;
  movePiece: (from: Position, to: Position) => void;
  initializeBoard: () => void;
  isValidMove: (from: Position, to: Position) => boolean;
  closeModal: () => void;
  createRoom: () => void;
  joinRoom: (roomId: string) => void;
}

export const useGameStore = create<GameState>((set, get) => ({
  chess: new Chess(),
  board: convertBoardFromChess(new Chess()),
  selectedPiece: null,
  currentPlayer: "white",
  moves: [],
  capturedPieces: {
    white: [],
    black: [],
  },
  isCheckmate: false,
  isStalemate: false,
  modalState: {
    isOpen: false,
    title: "",
    message: "",
    type: "check",
  },
  roomId: null,
  isMultiplayer: false,
  playerColor: null,

  selectPiece: (position) =>
    set((state) => {
      // Oyun bittiyse se√ßim yapƒ±lmamalƒ±
      if (state.isCheckmate || state.isStalemate) return state;

      // Multiplayer modunda oyuncular sadece kendi renklerini se√ßebilmeli
      if (state.isMultiplayer) {
        const piece = state.board[position.y][position.x];
        if (!piece || piece.color !== state.playerColor) return state;

        return {
          ...state,
          selectedPiece: {
            position,
            piece,
          },
        };
      }

      // Single player modunda sadece beyaz ta≈ülarƒ± se√ßebiliriz (AI siyah olduƒüu i√ßin)
      if (!state.isMultiplayer && state.currentPlayer === "black") return state;

      const piece = state.board[position.y][position.x];
      if (!piece || piece.color !== state.currentPlayer) return state;

      return {
        ...state,
        selectedPiece: {
          position,
          piece,
        },
      };
    }),

  movePiece: (from, to) =>
    set((state) => {
      // Oyun bittiyse hamle yapƒ±lamaz
      if (state.isCheckmate || state.isStalemate) {
        return state;
      }

      try {
        const fromSquare = convertToChessNotation(from);
        const toSquare = convertToChessNotation(to);

        // Hamleyi yapmadan √∂nce kontrol: Doƒüru renkteki ta≈üƒ± mƒ± hareket ettiriyoruz?
        const piece = state.board[from.y][from.x];
        if (!piece) {
          console.log("Ta≈ü bulunamadƒ±:", from);
          return state;
        }

        // Multiplayer modunda, sadece kendi rengimizi ve sƒ±ramƒ±z geldiƒüinde hareket ettirebiliriz
        if (state.isMultiplayer) {
          if (piece.color !== state.playerColor) {
            console.log("Kendi ta≈üƒ±nƒ±zƒ± se√ßmelisiniz");
            return state;
          }

          // Eƒüer oyuncunun rengi ile current player uyu≈ümuyorsa hamle yapamaz
          if (state.playerColor !== state.currentPlayer) {
            console.log("Sƒ±ra sizde deƒüil");
            return state;
          }
        } else if (piece.color !== state.currentPlayer) {
          // Tekli oyun modunda sadece sƒ±rasƒ± gelen oyuncu hamle yapabilir
          console.log("Sƒ±rasƒ± olmayan ta≈üla hamle yapƒ±lamaz");
          return state;
        }

        const moveResult = state.chess.move({
          from: fromSquare,
          to: toSquare,
          promotion: "q",
        });

        if (!moveResult) {
          console.log("Ge√ßersiz hamle:", from, "->", to);
          return state;
        }

        // Tahtayƒ± ve yakalanan ta≈ülarƒ± g√ºncelle
        const newBoard = convertBoardFromChess(state.chess);
        const newCapturedPieces = { ...state.capturedPieces };

        if (moveResult.captured) {
          const capturedType = pieceTypeMap[moveResult.captured];
          const capturedPiece = {
            type: capturedType,
            color: state.currentPlayer === "white" ? "black" : "white",
            hasMoved: true,
          };
          newCapturedPieces[
            state.currentPlayer === "white" ? "black" : "white"
          ].push(capturedPiece);
        }

        // Multiplayer modunda hamleyi g√∂nder
        if (state.isMultiplayer && state.roomId) {
          console.log("Hamle g√∂nderiliyor:", {
            from: fromSquare,
            to: toSquare,
          });
          socket.emit("move", {
            roomId: state.roomId,
            move: { from: fromSquare, to: toSquare },
          });
        }

        // ≈ûah/mat/pat durumlarƒ±nƒ± kontrol et
        const isInCheckmate = state.chess.isCheckmate();
        const isInStalemate = state.chess.isStalemate();
        const isInCheck = state.chess.inCheck();

        // Yeni state'i olu≈ütur
        const newState = {
          ...state,
          board: newBoard,
          selectedPiece: null,
          // Multiplayer modunda sƒ±ra diƒüer oyuncuya ge√ßer, tek oyunculuda ise AI hamlesi yapƒ±lacak
          currentPlayer: state.currentPlayer === "white" ? "black" : "white",
          moves: [...state.moves, { from, to }],
          capturedPieces: newCapturedPieces,
          isCheckmate: isInCheckmate,
          isStalemate: isInStalemate,
          modalState: isInStalemate
            ? {
                isOpen: true,
                title: "ü§ù Pat!",
                message: "Oyun berabere bitti!",
                type: "stalemate",
              }
            : isInCheckmate
            ? {
                isOpen: true,
                title: "‚ôö ≈ûah Mat!",
                message: `${
                  state.currentPlayer === "white" ? "Beyaz" : "Siyah"
                } oyuncu kazandƒ±!`,
                type: "checkmate",
              }
            : isInCheck
            ? {
                isOpen: true,
                title: "‚ôö ≈ûah!",
                message: `${
                  state.currentPlayer === "white" ? "Siyah" : "Beyaz"
                } ≈üah √ßekildi!`,
                type: "check",
              }
            : state.modalState,
        };

        // Tek oyuncu modunda ve oyun bitmemi≈üse AI hamlesi yap
        if (!state.isMultiplayer && !isInCheckmate && !isInStalemate) {
          setTimeout(() => {
            const bestMove = findBestMove(state.chess);
            if (bestMove) {
              const aiMoveResult = state.chess.move(bestMove);
              const aiBoard = convertBoardFromChess(state.chess);

              if (aiMoveResult.captured) {
                const capturedType = pieceTypeMap[aiMoveResult.captured];
                const capturedPiece = {
                  type: capturedType,
                  color: "white",
                  hasMoved: true,
                };
                newCapturedPieces.white = [
                  ...newCapturedPieces.white,
                  capturedPiece,
                ];
              }

              const playerInCheckmate = state.chess.isCheckmate();
              const playerInStalemate = state.chess.isStalemate();
              const playerInCheck = state.chess.inCheck();

              set({
                ...newState,
                board: aiBoard,
                currentPlayer: "white", // AI sonrasƒ± sƒ±ra yine oyuncuya (beyaz) ge√ßer
                isCheckmate: playerInCheckmate,
                isStalemate: playerInStalemate,
                modalState: playerInStalemate
                  ? {
                      isOpen: true,
                      title: "ü§ù Pat!",
                      message: "Oyun berabere bitti!",
                      type: "stalemate",
                    }
                  : playerInCheckmate
                  ? {
                      isOpen: true,
                      title: "‚ôö ≈ûah Mat!",
                      message: "√úzg√ºn√ºm, AI sizi mat etti!",
                      type: "checkmate",
                    }
                  : playerInCheck
                  ? {
                      isOpen: true,
                      title: "‚ôö ≈ûah!",
                      message: "Beyaz ≈üah √ßekildi!",
                      type: "check",
                    }
                  : { ...state.modalState, isOpen: false },
              });
            }
          }, 1000);
        }

        return newState;
      } catch (error) {
        console.error("Hamle yapƒ±lƒ±rken hata:", error);
        return state;
      }
    }),

  initializeBoard: () =>
    set(() => ({
      chess: new Chess(),
      board: convertBoardFromChess(new Chess()),
      selectedPiece: null,
      currentPlayer: "white",
      moves: [],
      capturedPieces: {
        white: [],
        black: [],
      },
      isCheckmate: false,
      isStalemate: false,
      modalState: {
        isOpen: false,
        title: "",
        message: "",
        type: "check",
      },
      roomId: null,
      isMultiplayer: false,
      playerColor: null,
    })),

  isValidMove: (from, to) => {
    const state = get();
    const fromSquare = convertToChessNotation(from);
    const toSquare = convertToChessNotation(to);

    try {
      const moves = state.chess.moves({ square: fromSquare, verbose: true });
      return moves.some((move) => move.to === toSquare);
    } catch (error) {
      console.error("Hamle ge√ßerliliƒüi kontrol edilirken hata:", error);
      return false;
    }
  },

  closeModal: () =>
    set((state) => ({
      ...state,
      modalState: { ...state.modalState, isOpen: false },
    })),

  createRoom: () => {
    // √ñnceki event listener'larƒ± temizle
    socket.off("roomCreated");
    socket.off("gameStart");
    socket.off("moveMade");
    socket.off("playerLeft");

    // Oda olu≈üturma isteƒüi g√∂nder
    socket.emit("createRoom");

    // Yeni event listener'larƒ± ekle
    socket.on("roomCreated", (roomId: string) => {
      set({
        chess: new Chess(), // Yeni oyun ba≈ülat
        board: convertBoardFromChess(new Chess()),
        selectedPiece: null,
        currentPlayer: "white",
        moves: [],
        capturedPieces: {
          white: [],
          black: [],
        },
        isCheckmate: false,
        isStalemate: false,
        roomId,
        isMultiplayer: true,
        playerColor: "white",
        modalState: {
          isOpen: true,
          title: "‚úÖ Oda Olu≈üturuldu",
          message: `Oda kodu: ${roomId}. Rakibinizin katƒ±lmasƒ±nƒ± bekleyin.`,
          type: "check",
        },
      });
      console.log("Oda olu≈üturuldu:", roomId);
    });

    socket.on("gameStart", (gameData) => {
      console.log("Oyun ba≈üladƒ±:", gameData);
      set((state) => ({
        ...state,
        modalState: {
          isOpen: true,
          title: "üéÆ Oyun Ba≈üladƒ±!",
          message: "Rakip odaya katƒ±ldƒ±. Beyaz ta≈ü olarak ba≈ülƒ±yorsunuz.",
          type: "check",
        },
      }));
    });

    socket.on("moveMade", (move) => {
      console.log("Beyaz oyuncu i√ßin hamle alƒ±ndƒ±:", move);
      const state = get();
      try {
        // Chess.js hamle formatƒ±na √ßevir
        const moveResult = state.chess.move(move);
        if (moveResult) {
          const newBoard = convertBoardFromChess(state.chess);

          // Eƒüer ta≈ü alƒ±ndƒ±ysa yakalanan ta≈ülarƒ± g√ºncelle
          const newCapturedPieces = { ...state.capturedPieces };
          if (moveResult.captured) {
            const capturedType = pieceTypeMap[moveResult.captured];
            const capturedPiece = {
              type: capturedType,
              color: "white",
              hasMoved: true,
            };
            newCapturedPieces.white = [
              ...newCapturedPieces.white,
              capturedPiece,
            ];
          }

          const isInCheckmate = state.chess.isCheckmate();
          const isInStalemate = state.chess.isStalemate();
          const isInCheck = state.chess.inCheck();

          set({
            board: newBoard,
            currentPlayer: "white", // Sƒ±ra beyaz oyuncuya ge√ßer
            capturedPieces: newCapturedPieces,
            isCheckmate: isInCheckmate,
            isStalemate: isInStalemate,
            modalState: isInStalemate
              ? {
                  isOpen: true,
                  title: "ü§ù Pat!",
                  message: "Oyun berabere bitti!",
                  type: "stalemate",
                }
              : isInCheckmate
              ? {
                  isOpen: true,
                  title: "‚ôö ≈ûah Mat!",
                  message: "Siyah oyuncu kazandƒ±!",
                  type: "checkmate",
                }
              : isInCheck
              ? {
                  isOpen: true,
                  title: "‚ôö ≈ûah!",
                  message: "Beyaz ≈üah √ßekildi!",
                  type: "check",
                }
              : { ...state.modalState, isOpen: false },
          });
        }
      } catch (error) {
        console.error("Ge√ßersiz hamle:", error);
      }
    });

    socket.on("playerLeft", () => {
      set((state) => ({
        ...state,
        modalState: {
          isOpen: true,
          title: "‚ö†Ô∏è Rakip Ayrƒ±ldƒ±",
          message: "Rakip oyundan ayrƒ±ldƒ±.",
          type: "check",
        },
      }));

      // Multiplayer modunu kapat
      setTimeout(() => {
        set({
          chess: new Chess(),
          board: convertBoardFromChess(new Chess()),
          selectedPiece: null,
          currentPlayer: "white",
          moves: [],
          capturedPieces: {
            white: [],
            black: [],
          },
          isCheckmate: false,
          isStalemate: false,
          modalState: {
            isOpen: false,
            title: "",
            message: "",
            type: "check",
          },
          roomId: null,
          isMultiplayer: false,
          playerColor: null,
        });
      }, 3000);
    });
  },

  joinRoom: (roomId: string) => {
    // √ñnceki event listener'larƒ± temizle
    socket.off("joinedRoom");
    socket.off("joinError");
    socket.off("gameStart");
    socket.off("moveMade");
    socket.off("playerLeft");

    // Odaya katƒ±lma isteƒüi g√∂nder
    socket.emit("joinRoom", roomId);

    // Yeni event listener'larƒ± ekle
    socket.on("joinedRoom", () => {
      set({
        chess: new Chess(), // Yeni oyun ba≈ülat
        board: convertBoardFromChess(new Chess()),
        selectedPiece: null,
        currentPlayer: "white", // ƒ∞lk olarak beyaz ba≈ülar, ancak bizim rengimiz siyah
        moves: [],
        capturedPieces: {
          white: [],
          black: [],
        },
        isCheckmate: false,
        isStalemate: false,
        roomId,
        isMultiplayer: true,
        playerColor: "black",
        modalState: {
          isOpen: true,
          title: "üéÆ Oyuna Katƒ±ldƒ±nƒ±z!",
          message: "Siyah ta≈ü olarak oynuyorsunuz. Beyazƒ±n hamlesini bekleyin.",
          type: "check",
        },
      });
      console.log("Odaya katƒ±lƒ±ndƒ±:", roomId);
    });

    socket.on("joinError", (error) => {
      console.error("Odaya katƒ±lma hatasƒ±:", error);
      set((state) => ({
        ...state,
        modalState: {
          isOpen: true,
          title: "‚ö†Ô∏è Hata",
          message: "Odaya katƒ±lƒ±namadƒ±: " + error,
          type: "check",
        },
      }));
    });

    socket.on("moveMade", (move) => {
      console.log("Siyah oyuncu i√ßin hamle alƒ±ndƒ±:", move);
      const state = get();
      try {
        // Chess.js hamle formatƒ±na √ßevir
        const moveResult = state.chess.move(move);
        if (moveResult) {
          const newBoard = convertBoardFromChess(state.chess);

          // Eƒüer ta≈ü alƒ±ndƒ±ysa yakalanan ta≈ülarƒ± g√ºncelle
          const newCapturedPieces = { ...state.capturedPieces };
          if (moveResult.captured) {
            const capturedType = pieceTypeMap[moveResult.captured];
            const capturedPiece = {
              type: capturedType,
              color: "black",
              hasMoved: true,
            };
            newCapturedPieces.black = [
              ...newCapturedPieces.black,
              capturedPiece,
            ];
          }

          const isInCheckmate = state.chess.isCheckmate();
          const isInStalemate = state.chess.isStalemate();
          const isInCheck = state.chess.inCheck();

          set({
            board: newBoard,
            currentPlayer: "black", // Sƒ±ra siyah oyuncuya ge√ßer
            capturedPieces: newCapturedPieces,
            isCheckmate: isInCheckmate,
            isStalemate: isInStalemate,
            modalState: isInStalemate
              ? {
                  isOpen: true,
                  title: "ü§ù Pat!",
                  message: "Oyun berabere bitti!",
                  type: "stalemate",
                }
              : isInCheckmate
              ? {
                  isOpen: true,
                  title: "‚ôö ≈ûah Mat!",
                  message: "Beyaz oyuncu kazandƒ±!",
                  type: "checkmate",
                }
              : isInCheck
              ? {
                  isOpen: true,
                  title: "‚ôö ≈ûah!",
                  message: "Siyah ≈üah √ßekildi!",
                  type: "check",
                }
              : { ...state.modalState, isOpen: false },
          });
        }
      } catch (error) {
        console.error("Ge√ßersiz hamle:", error);
      }
    });

    socket.on("playerLeft", () => {
      set((state) => ({
        ...state,
        modalState: {
          isOpen: true,
          title: "‚ö†Ô∏è Rakip Ayrƒ±ldƒ±",
          message: "Rakip oyundan ayrƒ±ldƒ±.",
          type: "check",
        },
      }));

      // Multiplayer modunu kapat
      setTimeout(() => {
        set({
          chess: new Chess(),
          board: convertBoardFromChess(new Chess()),
          selectedPiece: null,
          currentPlayer: "white",
          moves: [],
          capturedPieces: {
            white: [],
            black: [],
          },
          isCheckmate: false,
          isStalemate: false,
          modalState: {
            isOpen: false,
            title: "",
            message: "",
            type: "check",
          },
          roomId: null,
          isMultiplayer: false,
          playerColor: null,
        });
      }, 3000);
    });
  },
}));
